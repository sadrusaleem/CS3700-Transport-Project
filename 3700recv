#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

from logger import Logger


MSG_SIZE = 1500
TIMEOUT = 30


log = Logger({
    "port_bound": "[bound] {port}",
    "transfer_complete": "[completed]",
    "packet_recv": "[recv data] {start} ({length}) {status}",
    "packet_corruct": "[recv corrupt packet]",
    "err_timeout": "[error] timeout waiting to read input data",
    "packet_incomplete": "[error] packet send failed before completion"
}, stdout=sys.stderr)


def main():
    Receiver().start()


class Receiver():
    def __init__(self):
        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind(("", 0))
        self.sock.settimeout(TIMEOUT)

        # Get port we bound to
        UDP_PORT = int(self.sock.getsockname()[1])

        # For some reason, the first will not print. Why? I don't know.
        log.success("port_bound", port=UDP_PORT)
        log.success("port_bound", port=UDP_PORT)

        self.next_sequence_to_print = 0

    def start(self):
        # Now listen for packets
        while True:
            result = self.sock.recvfrom(MSG_SIZE)

            # If nothing is ready, we hit the timeout
            if result:
                data, addr = result

                try:
                    decoded = json.loads(data)

                    # If the EOF flag is set, exit
                    if (decoded["eof"]):
                        log.success("transfer_complete")
                        return

                    data, seq = decoded["data"], decoded["sequence"]
                    length = len(data)

                    # If there is data, we accept it and print it out
                    if (data):
                        status = ""

                        if seq == self.next_sequence_to_print:
                            status = "ACCEPTED (in-order)"

                            sys.stdout.write(data)
                            self.next_sequence_to_print += length

                            # Send back an ack to the sender
                            msg = json.dumps({ "ack": seq + length })

                            if self.sock.sendto(msg, addr) < len(msg):
                                log.err("packet_incomplete")

                        elif seq < self.next_sequence_to_print:
                            status = "IGNORED"
                        elif seq > self.next_sequence_to_print:
                            status = "ACCEPTED (out-of-order)"

                        log.success("packet_recv",
                            start=seq, length=length, status=status)

                except (ValueError, KeyError, TypeError):
                    log.err("packet_corrupt")
                    raise
            else:
                log.err("err_timeout")
                raise RuntimeError("Error: read timeout")


if __name__ == "__main__":
    main()
