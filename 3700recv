#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

from logger import Logger, FileLogger


MSG_SIZE = 1500
TIMEOUT = 30


# def StdErrLogger(Logger):
#     def _do_log(self, msg):
#         """Logs to `stderr` instead of `stdout`"""
#         sys.stderr.write(msg)
#         sys.stderr.flush()


# log = FileLogger("test.log", {
#     "transfer_complete": "[complete]",
#     "port_bound": "[bound] {port}",
#     "packet_recv": "[recv data] {start} ({length}) {status}",
#     "packet_corruct": "[recv corrupt packet]"
#     # "[error] timeout"
#     # "[completed]"
#     # "ABOUT TO SEND %s"
#     # "[error] unable to fully send packet"
# })


def main():
    Receiver().start()


class Receiver():
    def __init__(self):
        # Bind to localhost and an ephemeral port
        UDP_IP = "127.0.0.1"
        UDP_PORT = 0

        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind((UDP_IP, UDP_PORT))
        self.sock.settimeout(TIMEOUT)

        # Get port we bound to
        UDP_PORT = self.sock.getsockname()[1]
        # log.success("port_bound", port=UDP_PORT)
        self.log("[bound] %d" % UDP_PORT)

        self.next_sequence_to_print = 0

    def log(self, string):
        sys.stderr.write(
            datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

    def start(self):
        # Now listen for packets
        while True:
            result = self.sock.recvfrom(MSG_SIZE)

            # If nothing is ready, we hit the timeout
            if result:
                data, addr = result

                try:
                    decoded = json.loads(data)

                    # If the EOF flag is set, exit
                    if (decoded["eof"]):
                        self.log("[completed]")
                        return

                    data, seq = decoded["data"], decoded["sequence"]
                    length = len(data)

                    # If there is data, we accept it and print it out
                    if (data):
                        if seq == self.next_sequence_to_print:
                            self.log("[recv data] %(seq)d (%(length)d) ACCEPTED (in-order)" % {
                                "seq": seq,
                                "length": length
                            })

                            sys.stdout.write(data)
                            self.next_sequence_to_print += length

                            # Send back an ack to the sender
                            msg = json.dumps({ "ack": seq + length })
                            self.log("ABOUT TO SEND %s" % msg)

                            if self.sock.sendto(msg, addr) < len(msg):
                                self.log("[error] unable to fully send packet")

                        elif seq < self.next_sequence_to_print:
                            self.log("recieved a dup packet %(seq)d (%(length)d)" % {
                                "seq": seq,
                                "len": length
                            })
                        elif seq > self.next_sequence_to_print:
                            self.log("recieved out of order packet %(seq)d (%(length)d)" % {
                                "seq": seq,
                                "len": length
                            })

                except (ValueError, KeyError, TypeError):
                    self.log("[recv corrupt packet]")
                    raise
            else:
                self.log("[error] timeout")
                raise RuntimeError("Error: read timeout")


if __name__ == "__main__":
    main()
