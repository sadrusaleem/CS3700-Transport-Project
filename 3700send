#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
import errno
from time import time
import traceback

from logger import Logger

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
# 0 means trust new RTT all the way
# 1 means trust the old RTT all the way
NEW_RTT_LEAN = .875
# RTO will be 5 * RTT
RTO_TO_RTT_FACTOR = 5


log = Logger({
    "eof": "[eof] reached EOF",
    "transfer_complete": "[completed]",
    "packet_sent": "[send data] {seq_num} ({len})",
    "packet_incomplete": "[error] packet send failed before completion",
    "packet_ack": "[send received-ack] {seq_num}",
    "packet_corrupt": "[recv corrupt packet] received corrupt packet\n{error}\n",
    "packet_retransmit": "[retransmit packet] {seq_num}",
    "rtt_update": "[rtt update] old: {old:1.3f}s, sample: {sample:1.3f}s, new: {new:1.3f}s",
    "cwnd_update": "[cwnd update] old: {old}, new: {new}",
    "cwnd_reset": "[cwnd RESET] old: {old}, new: 1"
}, stdout=sys.stderr)


def main(recv_host, recv_port):
    Sender(recv_host, int(recv_port)).start()

class Sender():
    def __init__(self, recv_host, recv_port):
        # Bind to localhost and an ephemeral port
        self.dest = (recv_host, recv_port)

        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.settimeout(0)  # want the socket to be non-blocking

        self.sequence = 0
        self.cwnd = 1  # number of un-acked packets allowed to be in flight
        self.packet_buffer = {}  # keep track of un-acked packets (maps sequence nums to packets)

        # these will get set once we get our first sample
        self.rto = None
        self.rtt = None

    def start(self):
        while True:
            # Try to send next packet; break if no more data
            if not self.send_packets() and not self.packet_buffer:
                log.info("eof")
                self.sock.sendto(json.dumps({
                    "sequence": self.sequence,
                    "data": "",
                    "ack": False,
                    "eof": True,
                }), self.dest)
                break

            self.ack_packets()
            self.retransmit_packets()
        log.success("transfer_complete")
        sys.stdout.flush()

    def send_packets(self):
        while len(self.packet_buffer) < self.cwnd:
            # can push more packets onto the wire
            data = sys.stdin.read(DATA_SIZE)
            if len(data) > 0:
                msg = json.dumps({
                    "sequence": self.sequence,
                    "data": data,
                    "ack": False,
                    "eof": False
                })

                if self.send_packet(msg):
                    log.success("packet_sent",
                        seq_num=self.sequence,
                        len=len(data))

                    self.sequence += len(data)
                    self.packet_buffer[self.sequence] = {
                        "msg": msg,
                        "time_sent": time()
                    }
            else:
                return False

        return True

    def send_packet(self, msg):
        if self.sock.sendto(msg, self.dest) < len(msg):
            log.err("packet_incomplete")
            return False
        return True

    def ack_packets(self):
        # Now read in data, send packets
        result = self.recv_packets()

        while result:
            data, addr = result
            try:
                decoded = json.loads(data)
                ack_num = decoded.get("ack")

                acked_packet = self.packet_buffer.pop(ack_num)  # throws error if ack_num isn't there

                # know we successfully ack'ed a packet if we get here
                log.success("packet_ack", seq_num=ack_num - DATA_SIZE) #the ack num sent back is start seq + DATA_SIZE
                self.update_rtt(time() - acked_packet["time_sent"])

                log.info("cwnd_update", old=self.cwnd, new=self.cwnd+1)
                self.cwnd += 1 #TODO: make this smart
            except KeyError:
                #means we received a duplicate ack
                pass
            except Exception, e:
                log.info("packet_corrupt", error="")

            result = self.recv_packets()

    def update_rtt(self, new_sample):
        old_rtt = self.rtt or 0
        if self.rtt:
            self.rtt = (NEW_RTT_LEAN * self.rtt) + ((1 - NEW_RTT_LEAN) * new_sample)
        else:
            self.rtt = new_sample
        self.rto = self.rtt * RTO_TO_RTT_FACTOR
        log.info("rtt_update", old=old_rtt, sample=new_sample, new=self.rtt)

    def recv_packets(self):
        # returns msg or None if unable to read, doesn't block
        try:
            return self.sock.recvfrom(MSG_SIZE)
        except socket.error, e:
            if e.args[0] not in (errno.EAGAIN, errno.EWOULDBLOCK):
                # a "real" error occurred, otheriwse there was just no data available
                log.err("error_read", error=str(e))
            return None

    def retransmit_packets(self):
        curr_time = time()

        for seq,data in self.packet_buffer.iteritems():
            time_sent, msg = data["time_sent"], data["msg"]

            if self.rto and (curr_time - time_sent) > self.rto:
                if self.send_packet(msg):
                    log.info("packet_retransmit", seq_num = seq - DATA_SIZE) #the seq num in packet_buffer maps the end seq #
                    data["time_sent"] = curr_time

                log.info("cwnd_reset", old=self.cwnd)
                self.cwnd = 1

if __name__ == "__main__":
    main(*sys.argv[1].split(":"))
