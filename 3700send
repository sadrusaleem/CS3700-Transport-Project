#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
import errno
from time import time
import traceback

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
# 0 means trust new RTT all the way
# 1 means trust the old RTT all the way
NEW_RTT_LEAN = .875
# RTO will be 5 * RTT
RTO_TO_RTT_FACTOR = 5

def main(recv_host, recv_port):
    Sender(recv_host, int(recv_port)).start()

class Sender():
    def __init__(self, recv_host, recv_port):
        # Bind to localhost and an ephemeral port
        self.dest = (recv_host, recv_port)

        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.settimeout(0)  # want the socket to be non-blocking

        self.sequence = 0
        self.cwnd = 1  # number of un-acked packets allowed to be in flight
        self.packet_buffer = {}  # keep track of un-acked packets (maps sequence nums to packets)

        # these will get set once we get our first sample
        self.rto = None
        self.rtt = None

    def log(self, string):
        sys.stderr.write(
            datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

    def start(self):
        while True:
            # Try to send next packet; break if no more data
            if not self.send_packets():
                self.log("EOF reached")
                self.sock.sendto(json.dumps({
                    "eof": True,
                    "data": "",
                    "sequence": self.sequence,
                    "ack": False
                }), self.dest)
                break

            self.ack_packets()
            self.retransmit_packets()

    def send_packets(self):
        while len(self.packet_buffer) < self.cwnd:
            # can push more packets onto the wire
            data = sys.stdin.read(DATA_SIZE)
            if len(data) > 0:
                msg = json.dumps({
                    "sequence": self.sequence,
                    "data": data,
                    "ack": False,
                    "eof": False
                })

                if self.send_packet(msg):
                    self.log("[send data] %(seq)d (%(len)d)" % {
                        "seq": self.sequence,
                        "len": len(data)
                    })
                    # CHECK - should sequence just increment?
                    self.sequence += len(data)
                    self.packet_buffer[self.sequence] = {
                        "msg": msg,
                        "time_sent": time()
                    }
            else:
                return False

        return True

    def send_packet(self, msg):
        if self.sock.sendto(msg, self.dest) < len(msg):
            self.log("[error] unable to fully send packet")
            return False
        return True

    def ack_packets(self):
        # Now read in data, send packets
        result = self.recv_packets()

        while result:
            data, addr = result
            try:
                decoded = json.loads(data)
                ack_num = decoded.get("ack")

                acked_packet = self.packet_buffer.pop(ack_num)  # throws error if ack_num isn't there

                # know we successfully ack'ed a packet if we get here
                self.log("[recv ack] %d" % ack_num)
                self.update_rtt(time() - acked_packet["time_sent"])

                self.cwnd += 1 #TODO: make this smart

            except (ValueError, KeyError, TypeError), e:
                self.log("[recv corrupt packet] %(err)s %(buff)s" % {
                    "err": str(e),
                    "buff": str(self.packet_buffer)
                })

            result = self.recv_packets()

    def update_rtt(self, new_sample):
        old_rtt = self.rtt
        if self.rtt:
            self.rtt = (NEW_RTT_LEAN * self.rtt) + ((1 - NEW_RTT_LEAN) * new_sample)
        else:
            self.rtt = new_sample
        self.rto = self.rtt * RTO_TO_RTT_FACTOR
        self.log("old rtt: %(old)f, sample: %(sample)f, new rtt: %(new)f" % {
            "old": old_rtt,
            "sample": new_sample,
            "new": self.rtt
        })

    def recv_packets(self):
        # returns msg or None if unable to read, doesn't block
        try:
            return self.sock.recvfrom(MSG_SIZE)
        except socket.error, e:
            if e.args[0] not in (errno.EAGAIN, errno.EWOULDBLOCK):
                # a "real" error occurred, otheriwse there was just no data available
                self.log("Error while reading: %s" % str(e))
            return None

    def retransmit_packets(self):
        curr_time = time()

        for data in self.packet_buffer.itervalues():
            time_sent, msg = data["time_sent"], data["msg"]

            if self.rto and (curr_time - time_sent) > self.rto:
                if self.send_packet(msg):
                    self.log("retransmitting packet")
                    data["time_sent"] = curr_time

                self.cwnd = 1

if __name__ == "__main__":
    main(*sys.argv[1].split(":"))
